/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Sun Dec 05 2021 19:59:25 GMT+0000 (Coordinated Universal Time).
 */



 define(['jointjs', 'css!./styles/PetriVisWidget.css'], function (joint) {
    'use strict';

    var WIDGET_CLASS = 'petri-vis';

    function PetriVisWidget(logger, container) {
        this._logger = logger.fork('Widget');

        this._el = container;

        this.nodes = {};
        this._initialize();

        this._logger.debug('ctor finished');
    }

    PetriVisWidget.prototype._initialize = function () {
        console.log(joint);
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        // set widget class
        this._el.addClass(WIDGET_CLASS);

        this._jointPN = new joint.dia.Graph;
        this._jointPaper = new joint.dia.Paper({
            el: this._el,
            width : "100%",
            height: "100%",
            model: this._jointPN,
            interactive: false
        });

        // this._jointPaper.on('element:pointerdblclick', function(elementView) {
        //     const currentElement = elementView.model;
        //     // console.log(currentElement);
        //     if (self._webgmePN) {
        //         // console.log(self._webgmeSM.id2state[currentElement.id]);
        //         self._setCurrentState(self._webgmeSM.id2state[currentElement.id]);
        //     }
        // });

        // this._webgmePN = null;

    };

    PetriVisWidget.prototype.onWidgetContainerResize = function (new_width, new_height) {
        this._logger.debug('Widget is resizing...');
        // if (this._jointPaper){
        //     this._jointPaper.setDimensions(new_width, new_height);
        //     this._jointPaper.scaleContentToFit();
        // }
    };

    PetriVisWidget.prototype.initPetriNet = function (machineDescriptor) {
        const self = this;
        console.log(machineDescriptor);

        var tokens = joint.dia.Element.define('token', {
            attrs: {
                text: {
                    fontWeight: 'bold',
                    fontSize: 20,
                    refX: 22,
                    refY: 22
                }
            }
        },{
            markup: [{tagName: 'text', selector: 'text'}]
        });

        self._webgmePN = machineDescriptor;
        self._jointPN.clear();
        const pn = self._webgmePN;
        pn.id2state = {};
        Object.keys(pn.places).forEach(placeId => {
            // console.log(pn.places[placeId]);
            // console.log(placeId);
            let vertex = null;
            // if (this._el.width() <= pn.places[placeId].position.x){
            //     self.onWidgetContainerResize(pn.places[placeId].position.x + 100, this._el.height())
            // }

            vertex = new joint.shapes.standard.Circle({
                position: pn.places[placeId].position,
                size: { width: 60, height: 60 },
                attrs: {
                    label : {
                        text: pn.places[placeId].name,
                        //event: 'element:label:pointerdown',
                        fontWeight: 'bold',
                        'ref-y': 40
                        //cursor: 'text',
                        //style: {
                        //    userSelect: 'text'
                        //}
                    },
                    body: {
                        strokeWidth: 3
                    }
                }
            });
            let t = null;
            t = new tokens({
                position: pn.places[placeId].position,
                attrs: {
                    text: {
                        text: String(pn.places[placeId].tokens)
                    }
                }
            })
            
            vertex.addTo(self._jointPN);
            // t.attributes.attrs.text.text = String(pn.places[placeId].tokens - 1);
            t.addTo(self._jointPN);
            pn.places[placeId].joint = vertex;
            pn.places[placeId].joint_tk = t;
            pn.id2state[vertex.id] = placeId;
        });

        Object.keys(pn.transitions).forEach(transId => {
            // console.log(pn.places[placeId]);
            // console.log(placeId);
            let vertex = null;
            // if (this._el.width() <= pn.places[placeId].position.x){
            //     self.onWidgetContainerResize(pn.places[placeId].position.x + 100, this._el.height())
            // }

            vertex = new joint.shapes.standard.Rectangle({
                position: pn.transitions[transId].position,
                size: { width: 10, height: 60 },
                attrs: {
                    label : {
                        text: pn.transitions[transId].name,
                        //event: 'element:label:pointerdown',
                        fontWeight: 'bold',
                        'ref-y': 40
                        //cursor: 'text',
                        //style: {
                        //    userSelect: 'text'
                        //}
                    },
                    body: {
                        strokeWidth: 3,
                        fill: 'black'
                    }
                }
            });

            pn.transitions[transId].joint = vertex;
            vertex.addTo(self._jointPN);
            // pn.places[placeId].joint = vertex;
            // pn.id2state[vertex.id] = placeId;
        });

        Object.keys(pn.places).forEach(placeId => {
            const place = pn.places[placeId];
            Object.keys(place.next).forEach(event => {
                place.jointNext = place.jointNext || {};
                const link = new joint.shapes.standard.Link({
                    source: {id: place.joint.id},
                    target: {id: pn.transitions[place.next[event]].joint.id},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    },
                    labels: [{
                        position: {
                            distance: 0.5,
                            offset: 0,
                            args: {
                                keepGradient: true,
                                ensureLegibility: true
                            }
                        },
                        
                    }]
                });
                link.addTo(self._jointPN);
                place.jointNext[event] = link;
            })
        });

        Object.keys(pn.transitions).forEach(transId => {
            const trans = pn.transitions[transId];
            Object.keys(trans.next).forEach(place => {
                trans.jointNext = trans.jointNext || {};
                const link = new joint.shapes.standard.Link({
                    source: {id: trans.joint.id},
                    target: {id: pn.places[trans.next[place]].joint.id},
                    attrs: {
                        line: {
                            strokeWidth: 2
                        },
                        wrapper: {
                            cursor: 'default'
                        }
                    },
                    labels: [{
                        position: {
                            distance: 0.5,
                            offset: 0,
                            args: {
                                keepGradient: true,
                                ensureLegibility: true
                            }
                        },
                        
                    }]
                });
                link.addTo(self._jointPN);
                trans.jointNext[place] = link;
            })
        });
        // Object.keys(pn.places).forEach(placeId => {
        //     pn.places[placeId].joint_tk.attr('text/text', String(pn.places[placeId].tokens - 1));
        // });

        self._jointPaper.scaleContentToFit({padding: 50});
        self._jointPaper.updateViews();
        self._decorateMachine();

    };

    PetriVisWidget.prototype.destroyMachine = function () {

    };

    PetriVisWidget.prototype.fireEvent = function (event) {
        const self = this;
        const pn = this._webgmePN;
        Object.keys(pn.transitions[event].inPlaces).forEach(in_id =>{
                pn.places[in_id].tokens -= 1;
                pn.places[in_id].joint_tk.attr('text/text', String(pn.places[in_id].tokens));
                const link = pn.places[in_id].jointNext[event];
                const linkView = link.findView(self._jointPaper);
                linkView.sendToken(joint.V('circle', { r: 5, fill: 'black' }), {duration:500}, function() {});
        });
        setTimeout(function(){
            Object.keys(pn.transitions[event].next).forEach(out_id =>{
                pn.places[out_id].tokens += 1;
                pn.places[out_id].joint_tk.attr('text/text', String(pn.places[out_id].tokens));
                const link = pn.transitions[event].jointNext[out_id];
                const linkView = link.findView(self._jointPaper);
                linkView.sendToken(joint.V('circle', { r: 5, fill: 'black' }), {duration:500}, function() {});
            });
            self._decorateMachine();
        }, 500)

        

        // const current = self._webgmeSM.states[self._webgmeSM.current];
        // const link = current.jointNext[event];
        // const linkView = link.findView(self._jointPaper);
        // linkView.sendToken(joint.V('circle', { r: 10, fill: 'black' }), {duration:500}, function() {
        //    self._webgmeSM.current = current.next[event];
        //    self._decorateMachine();
        // });


    };

    PetriVisWidget.prototype.resetMachine = function () {
        this._webgmePN.places = JSON.parse(JSON.stringify(this._webgmePN.init.places));
        this._webgmePN.transitions = JSON.parse(JSON.stringify(this._webgmePN.init.transitions));
        this.initPetriNet(this._webgmePN);
    };

    PetriVisWidget.prototype._decorateMachine = function() {
        const pn = this._webgmePN;
        var enabledTransObj = {};
        Object.keys(pn.transitions).forEach(transId => {
            var enabledTrans = true;
            Object.keys(pn.transitions[transId].inPlaces).forEach(p_id => {
                if (pn.places[p_id].tokens === 0){
                    enabledTrans = false;
                }
            });
            if (Object.keys(pn.transitions[transId].inPlaces).length === 0){
                enabledTrans = false
            }
            if (enabledTrans){
                pn.transitions[transId].joint.attr('body/stroke', 'blue');
                enabledTransObj[transId] = pn.transitions[transId].name;
            }
            else{
                pn.transitions[transId].joint.attr('body/stroke', '#333333');
            }
            
        });
        pn.setFireableEvents(enabledTransObj);
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */


    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    PetriVisWidget.prototype.destroy = function () {
    };

    PetriVisWidget.prototype.onActivate = function () {
        this._logger.debug('PetriVisWidget has been activated');
    };

    PetriVisWidget.prototype.onDeactivate = function () {
        this._logger.debug('PetriVisWidget has been deactivated');
    };

    return PetriVisWidget;
});
